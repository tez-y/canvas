<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイム音階表示</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            flex-direction: column; /* 要素を縦に並べる */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 24px; /* パディングを少し小さく */
            width: 100%;
            max-width: 800px; /* Default for smaller screens */
        }
        @media (min-width: 768px) { /* md breakpoint */
            .container {
                max-width: 900px;
                padding: 32px; /* タブレット以上では元のパディングに戻す */
            }
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .container {
                max-width: 1024px; /* Wider for tablets/desktops */
            }
        }

        .button-primary {
            background-color: #4f46e5;
            color: white;
            padding: 10px 20px;
            border-radius: 9999px;
            font-weight: 600;
            transition: background-color 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            font-size: 0.95rem;
        }
        .button-primary:hover {
            background-color: #4338ca;
        }
        .button-danger {
            background-color: #ef4444;
            color: white;
            padding: 10px 20px;
            border-radius: 9999px;
            font-weight: 600;
            transition: background-color 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            font-size: 0.95rem;
        }
        .button-danger:hover {
            background-color: #dc2626;
        }
        .button-secondary {
            background-color: #6b7280;
            color: white;
            padding: 8px 16px;
            border-radius: 9999px;
            font-weight: 500;
            transition: background-color 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            font-size: 0.9rem;
        }
        .button-secondary:hover {
            background-color: #4b5563;
        }
        .status-message {
            margin-top: 20px; /* マージンを調整 */
            font-size: 1.125rem; /* text-lg */
            color: #4b5563;
        }
        .note-display-area {
            border: 2px dashed #a78bfa; /* 紫系の色に変更 */
            background-color: #ede9fe; /* 紫系の背景色 */
            border-radius: 12px;
            min-height: 200px;
            padding: 20px; /* パディングを維持 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #5b21b6;
            font-weight: bold;
            font-size: 3rem;
            line-height: 1.2;
            margin-top: 0; /* 親コンテナのgapで調整 */
        }
        .note-display-area .octave {
            font-size: 1.5rem;
            color: #8b5cf6;
            margin-top: 10px;
        }
        /* ライブ表示の音符の色を動的に変更するためのクラス */
        .note-display-area.correct {
            color: #10B981; /* Tailwind green-500 */
        }
        .note-display-area.incorrect {
            color: #EF4444; /* Tailwind red-500 */
        }

        .note-history-area {
            max-height: 250px; /* 履歴エリアの最大高さ */
            overflow-y: auto; /* 内容がはみ出たらスクロール */
            padding: 16px;
            background-color: #f9fafb;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            text-align: left;
            margin-top: 20px; /* 上部のマージンを調整 */
        }
        @media (min-width: 768px) {
            .note-history-area {
                max-height: 300px; /* 横長画面で高さを少し増やす */
            }
        }
        .note-history-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }
        .history-item {
            background-color: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        /* 履歴項目の色 */
        .history-item.correct-note {
            border-color: #10B981;
            background-color: #D1FAE5;
        }
        .history-item.incorrect-note {
            border-color: #EF4444;
            background-color: #FEE2E2;
        }
        .history-item.correct-note .note-text,
        .history-item.correct-note .duration-text {
            color: #065F46;
        }
        .history-item.incorrect-note .note-text,
        .history-item.incorrect-note .duration-text {
            color: #991B1B;
        }

        /* エラーメッセージボックスのスタイル */
        .error-box {
            background-color: #fee2e2;
            border: 1px solid #ef4444;
            color: #dc2626;
            padding: 16px;
            border-radius: 8px;
            margin-top: 24px;
            font-size: 0.95rem;
            text-align: left;
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            margin-bottom: 0;
        }
        .tempo-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tempo-control label {
            font-weight: 600;
            color: #4b5563;
            white-space: nowrap;
        }
        .tempo-control select {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            background-color: white;
            font-size: 0.95rem;
            color: #374151;
            cursor: pointer;
        }
        .tempo-info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 0;
        }

        /* 読み込んだ楽譜表示エリアのスタイル */
        .loaded-music-area {
            margin-top: 0; /* 親コンテナのgapで調整 */
            padding: 16px;
            background-color: #e0f2fe;
            border-radius: 12px;
            border: 1px solid #90cdf4;
            text-align: center;
        }
        .loaded-music-area h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2b6cb0;
            margin-bottom: 10px;
        }
        .loaded-music-notes {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        .loaded-note-item {
            background-color: #bfdbfe;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #1e40af;
            white-space: nowrap;
        }
        .loaded-note-item.current-expected {
            background-color: #fcd34d;
            color: #92400e;
            font-weight: 700;
            border: 2px solid #f59e0b;
        }

        /* ファイル選択エリアのスタイル */
        .file-input-group {
            margin-top: 0; /* 親のtop-controls-wrapperのgapで調整 */
            margin-bottom: 0; /* 親のtop-controls-wrapperのgapで調整 */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .file-input-group input[type="file"] {
            display: none;
        }
        .file-input-group .custom-file-upload {
            background-color: #3b82f6;
            color: white;
            padding: 8px 16px;
            border-radius: 9999px;
            font-weight: 500;
            transition: background-color 0.3s ease;
            cursor: pointer;
            border: none;
            outline: none;
            font-size: 0.9rem;
        }
        .file-input-group .custom-file-upload:hover {
            background-color: #2563eb;
        }
        .file-name-display {
            font-size: 0.9rem;
            color: #4b5563;
        }

        /* 新しいラッパー */
        .top-controls-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px; /* コントロールグループとファイル選択の間隔 */
            align-items: center;
            width: 100%;
        }
        @media (min-width: 768px) {
            .top-controls-wrapper {
                flex-direction: row; /* 横並びにする */
                justify-content: center; /* 中央揃え */
                flex-wrap: wrap; /* 必要に応じて折り返す */
            }
            .control-group, .file-input-group {
                margin-top: 0;
                margin-bottom: 0;
            }
        }

        .middle-display-wrapper {
            display: flex;
            flex-direction: column; /* デフォルトは縦積み（小画面用） */
            gap: 20px; /* 各セクション間のスペース */
            width: 100%;
            margin-top: 20px; /* 上部のマージン */
        }

        @media (min-width: 768px) { /* タブレット以上の画面サイズ */
            .middle-display-wrapper {
                flex-direction: row; /* 横並びにする */
                align-items: flex-start; /* 上揃え */
            }
            .note-display-area {
                flex: 1; /* 利用可能なスペースを均等に分配 */
                min-width: 280px; /* 最低幅を設定して潰れすぎないように */
            }
            .loaded-music-area { /* 読み込んだ楽譜エリアを横並びのもう一方に配置 */
                flex: 1.5; /* こちらを少し広めにする */
                min-width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-gray-800 mb-6">リアルタイム音階表示</h1>
        <p class="text-gray-600 mb-8">マイクからの笛の音を検出して音階として表示します。</p>

        <div class="top-controls-wrapper"> <!-- 新しいトップコントロールラッパー -->
            <div class="control-group">
                <button id="startButton" class="button-primary">マイクを開始</button>
                <button id="stopButton" class="button-danger" disabled>マイクを停止</button>
                
                <div class="tempo-control">
                    <label for="tempoSelect">テンポ (BPM):</label>
                    <select id="tempoSelect">
                        <option value="60">60</option>
                        <option value="90">90</option>
                        <option value="120" selected>120</option>
                        <option value="150">150</option>
                        <option value="180">180</option>
                    </select>
                </div>
                <p id="tempoInfo" class="tempo-info"></p>
            </div>

            <!-- ファイル選択エリア -->
            <div class="file-input-group">
                <label for="musicFileInput" class="custom-file-upload">
                    楽譜ファイルを選択
                </label>
                <input type="file" id="musicFileInput" accept=".txt">
                <span id="fileNameDisplay" class="file-name-display">ファイルが選択されていません</span>
            </div>
        </div> <!-- /top-controls-wrapper -->

        <p id="status" class="status-message">準備完了</p>

        <div class="middle-display-wrapper"> <!-- メインコンテンツの新しいラッパー -->
            <div id="noteDisplayArea" class="note-display-area">
                <p id="currentNote">---</p>
                <p id="currentOctave" class="octave"></p>
            </div>

            <!-- 読み込んだ楽譜表示エリア -->
            <div id="loadedMusicArea" class="loaded-music-area">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">読み込んだ楽譜</h3>
                <div id="loadedMusicNotes" class="loaded-music-notes">
                    <p class="text-gray-500 italic">楽譜ファイルを選択してください</p>
                </div>
            </div>
        </div> <!-- /middle-display-wrapper -->

        <div id="noteHistoryArea" class="note-history-area"> <!-- 記録された音は単独で下に大きく -->
            <h3 class="text-lg font-semibold text-gray-700 mb-2">記録された音</h3>
            <div id="historyGrid" class="note-history-grid">
                <!-- 検出された音がここに表示されます -->
            </div>
            <div class="mt-4 text-right">
                <button id="clearHistoryButton" class="button-secondary">履歴をクリア</button>
            </div>
        </div>

        <div id="errorMessage" class="error-box hidden"></div>
    </div>

    <script>
        let audioContext;
        let mediaStreamSource;
        let analyser;
        let animationFrameId;

        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusDisplay = document.getElementById('status');
        const noteDisplayArea = document.getElementById('noteDisplayArea');
        const currentNoteDisplay = document.getElementById('currentNote');
        const currentOctaveDisplay = document.getElementById('currentOctave');
        const errorMessageDisplay = document.getElementById('errorMessage');
        const loadedMusicArea = document.getElementById('loadedMusicArea');
        const loadedMusicNotes = document.getElementById('loadedMusicNotes');
        const noteHistoryArea = document.getElementById('noteHistoryArea');
        const historyGrid = document.getElementById('historyGrid');
        const tempoSelect = document.getElementById('tempoSelect');
        const tempoInfo = document.getElementById('tempoInfo');
        const clearHistoryButton = document.getElementById('clearHistoryButton');
        const musicFileInput = document.getElementById('musicFileInput');
        const fileNameDisplay = document.getElementById('fileNameDisplay');

        // 音符の名前の配列 (CからBまで)
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        // ドレミ表記の音符名
        const japaneseNoteStrings = ["ド", "ド#", "レ", "レ#", "ミ", "ファ", "ファ#", "ソ", "ソ#", "ラ", "ラ#", "シ"];

        // 検出された音の履歴を保存する配列 (オブジェクト形式で音符と長さを保存)
        let detectedNotesHistory = []; // Array of { note: string, octave: number, durationText: string, isCorrect: boolean | null }
        const MAX_HISTORY_ITEMS = 30; // 履歴に表示する最大項目数（グリッド表示に合わせて増やす）

        // 音の長さの目安判定用
        let lastStableNoteTime = 0; // 現在安定して検出されている音符が始まったタイムスタンプ
        let currentStableNote = { note: null, octave: null }; // 現在安定して検出されている音符
        // 履歴への重複記録を防ぐための変数（同じ音符と長さが連続して記録されるのを防ぐ）
        let lastRecordedNoteInHistory = { note: null, octave: null, durationText: null, isCorrect: null };

        // デバウンス処理のための変数
        let debouncedNote = { note: null, octave: null };
        let debouncedNoteStartTime = 0;
        const DEBOUNCE_THRESHOLD_MS = 100; // 音階が安定していると見なす最小時間 (ミリ秒)

        // 期待される音符のシーケンス
        let expectedNotes = []; // Array of { note: string, octave: number }
        let currentExpectedNoteIndex = 0; // 現在期待されている音符のインデックス

        // 周波数から最も近い音符とオクターブを計算する関数
        // 基準はA4 (440 Hz)
        function getNoteFromFrequency(frequency) {
            if (frequency <= 0) {
                return { note: "---", octave: "" };
            }

            const A4_FREQUENCY = 440;
            const SEMITONES_IN_OCTAVE = 12;
            const A4_MIDI_NUMBER = 69;

            const midiNoteNumber = SEMITONES_IN_OCTAVE * (Math.log(frequency / A4_FREQUENCY) / Math.LN2) + A4_MIDI_NUMBER;
            const roundedMidiNote = Math.round(midiNoteNumber);

            const noteIndex = roundedMidiNote % SEMITONES_IN_OCTAVE;
            const octave = Math.floor(roundedMidiNote / SEMITONES_IN_OCTAVE) - 1;

            return {
                note: japaneseNoteStrings[noteIndex],
                octave: octave
            };
        }

        // 検出された音の持続時間から音符の種類（全音符、四分音符など）を判断する関数
        function getNoteDurationText(durationMs, bpm) {
            const quarterNoteMs = (60 / bpm) * 1000; // 四分音符の基準ミリ秒

            if (durationMs >= quarterNoteMs * 3.5) return "全音符"; // 約4拍
            if (durationMs >= quarterNoteMs * 1.75) return "二分音符"; // 約2拍
            if (durationMs >= quarterNoteMs * 0.8) return "四分音符"; // 約1拍
            if (durationMs >= quarterNoteMs * 0.4) return "八分音符"; // 約0.5拍
            if (durationMs >= quarterNoteMs * 0.2) return "十六分音符"; // 約0.25拍
            return "短い音"; // その他の短い音
        }

        // テンポ情報表示を更新する関数
        function updateTempoInfo() {
            const bpm = parseInt(tempoSelect.value);
            const quarterNoteDurationMs = (60 / bpm) * 1000;
            tempoInfo.textContent = `${bpm} BPM (四分音符の長さ: ${quarterNoteDurationMs.toFixed(0)} ミリ秒)`;
        }

        // エラーメッセージを表示する関数
        function showErrorMessage(message) {
            errorMessageDisplay.innerHTML = message;
            errorMessageDisplay.classList.remove('hidden');
        }

        // エラーメッセージを非表示にする関数
        function hideErrorMessage() {
            errorMessageDisplay.classList.add('hidden');
            errorMessageDisplay.innerHTML = '';
        }

        // 読み込んだ楽譜を表示する関数
        function displayLoadedMusic() {
            if (expectedNotes.length === 0) {
                loadedMusicNotes.innerHTML = '<p class="text-gray-500 italic">楽譜ファイルを選択してください</p>';
                return;
            }

            loadedMusicNotes.innerHTML = expectedNotes.map((item, index) => {
                const isCurrent = (index === currentExpectedNoteIndex);
                return `
                    <div class="loaded-note-item ${isCurrent ? 'current-expected' : ''}">
                        ${item.note}${item.octave}
                    </div>
                `;
            }).join('');
        }

        // テキストファイルから音符をパースする関数
        function parseNotesFromString(text) {
            const parsedNotes = [];
            // 音名 (ドレミファソラシ) + シャープ (# or ＃)? + オクターブ (0-9 or ０-９)
            // 全角シャープと全角数字に対応
            const noteRegex = /([ドレミファソラシ][#＃]?)([0-9０-９])/g;
            let match;

            while ((match = noteRegex.exec(text)) !== null) {
                let noteName = match[1]; // 例: "ド", "レ#"
                let octaveStr = match[2]; // 例: "3", "５"

                // 全角数字を半角数字に変換
                octaveStr = octaveStr.replace(/[０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
                const octave = parseInt(octaveStr, 10);

                parsedNotes.push({ note: noteName, octave: octave });
            }
            return parsedNotes;
        }

        // 選択されたファイルを読み込む関数 (自動読み込みと手動選択の両方をサポート)
        async function loadMusicFile(file = null) {
            let fileContent = null;
            let loadedFileName = '';

            if (file) {
                // 手動ファイル選択の場合
                loadedFileName = file.name;
                hideErrorMessage();
                const reader = new FileReader();
                fileContent = await new Promise((resolve, reject) => {
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(reader.error);
                    reader.readAsText(file); // UTF-8として読み込む
                });
            } else {
                // 自動読み込み (music.txtを試行)
                loadedFileName = 'music.txt';
                try {
                    const response = await fetch('music.txt');
                    if (!response.ok) {
                        // ファイルが見つからない場合や読み込みエラーの場合
                        throw new Error(`ファイルが見つからないか、読み込みに失敗しました (${response.statusText || 'ネットワークエラー'})`);
                    }
                    fileContent = await response.text();
                } catch (error) {
                    console.error('Error loading music.txt automatically:', error);
                    expectedNotes = []; // 期待される音符を空にする
                    showErrorMessage(`music.txtが見つからないか、読み込みに失敗しました: ${error.message}。<br>手動で楽譜ファイルを選択してください。音符の判定は行われません。`);
                    fileNameDisplay.textContent = 'ファイルが選択されていません'; // ファイル名表示をリセット
                    displayLoadedMusic(); // 読み込んだ楽譜表示を更新して、ファイル選択を促すメッセージを表示
                    return; // 自動読み込みが失敗した場合は、これ以上処理を進めない
                }
            }

            // 共通のパースと表示ロジック
            try {
                expectedNotes = parseNotesFromString(fileContent);

                if (expectedNotes.length === 0) {
                    showErrorMessage(`「${loadedFileName}」に有効な音符がありません。ファイルの内容を確認してください。音符の判定は行われません。`);
                    statusDisplay.textContent = `「${loadedFileName}」に音符がありません`;
                } else {
                    statusDisplay.textContent = `楽譜ファイル「${loadedFileName}」を読み込みました。最初の音: ${expectedNotes[0].note}${expectedNotes[0].octave}`;
                }
                currentExpectedNoteIndex = 0; // ファイル読み込み時にインデックスをリセット
                fileNameDisplay.textContent = loadedFileName; // ファイル名表示を更新
                displayLoadedMusic(); // 読み込み後、楽譜を表示
            } catch (error) {
                console.error('Error parsing music file:', error);
                expectedNotes = [];
                showErrorMessage(`ファイルの解析に失敗しました: ${error.message}。<br>ファイルの内容が正しい形式か確認してください。音符の判定は行われません。`);
                displayLoadedMusic();
            }
        }

        // マイクを開始する関数
        async function startMicrophone() {
            hideErrorMessage();
            // 楽譜ファイルが読み込まれていない場合でも、アプリは動作させる
            if (expectedNotes.length === 0) {
                statusDisplay.textContent = '楽譜ファイルが読み込まれていないため、音符の判定は行われません。';
            }

            currentExpectedNoteIndex = 0;
            displayLoadedMusic();

            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaStreamSource = audioContext.createMediaStreamSource(stream);

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.minDecibels = -90;
                analyser.maxDecibels = -10;
                analyser.smoothingTimeConstant = 0.85;

                mediaStreamSource.connect(analyser);

                statusDisplay.textContent = 'マイク入力中...';
                startButton.disabled = true;
                stopButton.disabled = false;

                // マイク開始時に履歴記録およびデバウンス用の変数をリセット
                currentStableNote = { note: null, octave: null };
                lastStableNoteTime = performance.now();
                lastRecordedNoteInHistory = { note: null, octave: null, durationText: null, isCorrect: null };
                debouncedNote = { note: null, octave: null };
                debouncedNoteStartTime = 0;

                noteDisplayArea.classList.remove('correct', 'incorrect');
                currentNoteDisplay.style.color = '';
                currentOctaveDisplay.style.color = '';

                processAudio();

            } catch (err) {
                console.error('マイクアクセスエラー:', err);
                let userMessage = '<strong>マイクを有効にできませんでした。以下の点を確認してください:</strong><br>';
                if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    userMessage += '<ul><li>1. <strong>物理的なマイクの接続:</strong> マイクがPCに正しく接続されているか、または内蔵マイクが動作しているか確認してください。</li>';
                    userMessage += '<li>2. <strong>オペレーティングシステム（OS）のプライバシー設定:</strong> OS（Windows、macOSなど）の「プライバシー設定」または「セキュリティとプライバシー」で、お使いのブラウザ（例: Chrome, Firefox, Edge）がマイクにアクセスすることを許可しているか確認してください。</li>';
                    userMessage += '<li>3. <strong>ブラウザのサイト設定:</strong> ブラウザのアドレスバーの左側にある鍵アイコンや情報アイコンをクリックし、このサイトのマイクアクセスが「許可」になっているか確認してください。以前に「ブロック」した可能性があります。</li>';
                    userMessage += '<li>4. <strong>ブラウザの再起動:</strong> ブラウザを完全に閉じて再起動してみてください。</li>';
                    userMessage += '<li>5. <strong>別のブラウザで試す:</strong> 別のブラウザ（例: Chromeでうまくいかない場合、FirefoxやEdgeを試す）で動作するか確認してください。</li></ul>';
                } else if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    userMessage += '<strong>マイクへのアクセスが拒否されました。以下の点を確認してください:</strong><br>';
                    userMessage += '<ul><li>1. ブラウザのポップアップでマイク使用の許可を求められた際に「許可」を選択したか。</li>';
                    userMessage += '<li>2. ブラウザの設定で、このサイトのマイクアクセスがブロックされていないか。</li>';
                    userMessage += '<li>3. このページが安全な接続 (HTTPS://...) で提供されているか。</li></ul>';
                } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                    userMessage += '<strong>マイクが使用中です。</strong><br>他のアプリケーション（ビデオ会議ツールなど）がマイクを使用していないか確認してください。';
                } else if (err.name === 'OverconstrainedError') {
                    userMessage += '<strong>指定された制約を満たすマイクが見つかりませんでした。</strong><br>特定の種類のマイクを要求している場合に発生することがあります。';
                } else if (err.name === 'SecurityError') {
                    userMessage += '<strong>セキュリティ上の理由によりマイクにアクセスできません。</strong><br>このページが安全な接続 (HTTPS://...) で提供されているか。';
                } else {
                    userMessage += `予期せぬエラーが発生しました。エラー詳細: ${err.message}`;
                }
                showErrorMessage(userMessage);
                statusDisplay.textContent = 'エラー';
                startButton.disabled = false;
                stopButton.disabled = true;
            }
        }

        // 音声データを処理するループ
        function processAudio() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            let maxAmplitude = 0;
            let maxFrequencyIndex = -1;
            const MIN_AMPLITUDE_THRESHOLD = 120;

            for (let i = 0; i < bufferLength; i++) {
                if (dataArray[i] > maxAmplitude) {
                    maxAmplitude = dataArray[i];
                    maxFrequencyIndex = i;
                }
            }

            if (maxFrequencyIndex !== -1 && maxAmplitude > MIN_AMPLITUDE_THRESHOLD) {
                const sampleRate = audioContext.sampleRate;
                const detectedFrequency = maxFrequencyIndex * (sampleRate / analyser.fftSize);
                const { note, octave } = getNoteFromFrequency(detectedFrequency);

                // ライブ表示は常に最新の検出音を表示
                currentNoteDisplay.textContent = note;
                currentOctaveDisplay.textContent = octave;
                statusDisplay.textContent = `マイク入力中... (検出周波数: ${detectedFrequency.toFixed(2)} Hz)`;

                // --- デバウンスロジック開始 ---
                if (debouncedNote.note === null || note !== debouncedNote.note || octave !== debouncedNote.octave) {
                    // 新しい可能性のある音階が検出された場合、デバウンスタイマーをリセット
                    debouncedNote = { note, octave };
                    debouncedNoteStartTime = performance.now();
                } else {
                    // 同じ可能性のある音階が継続している場合、安定性をチェック
                    if (performance.now() - debouncedNoteStartTime >= DEBOUNCE_THRESHOLD_MS) {
                        // 音階が十分安定していると判断された場合
                        if (currentStableNote.note === null || debouncedNote.note !== currentStableNote.note || debouncedNote.octave !== currentStableNote.octave) {
                            // これは真に新しい安定した音階である
                            // まず、前の安定した音階が存在すれば、その期間を確定して履歴に追加
                            if (currentStableNote.note !== null) {
                                const durationMs = performance.now() - lastStableNoteTime;
                                const noteDurationText = getNoteDurationText(durationMs, parseInt(tempoSelect.value));
                                
                                let isCorrect = null;
                                if (expectedNotes.length > 0) {
                                    const expectedNoteObj = expectedNotes[currentExpectedNoteIndex];
                                    isCorrect = (currentStableNote.note === expectedNoteObj.note && currentStableNote.octave === expectedNoteObj.octave);
                                }

                                const newNoteEntry = {
                                    note: currentStableNote.note,
                                    octave: currentStableNote.octave,
                                    durationText: noteDurationText,
                                    isCorrect: isCorrect
                                };

                                // 履歴に同じ音符と長さの組み合わせが連続しないようにチェック
                                if (newNoteEntry.note !== lastRecordedNoteInHistory.note ||
                                    newNoteEntry.octave !== lastRecordedNoteInHistory.octave ||
                                    newNoteEntry.durationText !== lastRecordedNoteInHistory.durationText ||
                                    newNoteEntry.isCorrect !== lastRecordedNoteInHistory.isCorrect) {
                                    
                                    detectedNotesHistory.unshift(newNoteEntry);
                                    if (detectedNotesHistory.length > MAX_HISTORY_ITEMS) {
                                        detectedNotesHistory.pop();
                                    }
                                    historyGrid.innerHTML = detectedNotesHistory.map(item => `
                                        <div class="history-item ${item.isCorrect === true ? 'correct-note' : (item.isCorrect === false ? 'incorrect-note' : '')}">
                                            <p class="note-text">${item.note}${item.octave}</p>
                                            <p class="duration-text">${item.durationText}</p>
                                        </div>
                                    `).join('');
                                    lastRecordedNoteInHistory = newNoteEntry;
                                }
                            }
                            // 新しい安定した音階を設定
                            currentStableNote = { note: debouncedNote.note, octave: debouncedNote.octave };
                            lastStableNoteTime = performance.now();

                            // ライブ表示の色を更新（楽譜がある場合のみ）
                            if (expectedNotes.length > 0) {
                                const expectedNoteObj = expectedNotes[currentExpectedNoteIndex];
                                if (currentStableNote.note === expectedNoteObj.note && currentStableNote.octave === expectedNoteObj.octave) {
                                    noteDisplayArea.classList.remove('incorrect');
                                    noteDisplayArea.classList.add('correct');
                                    // 正しい場合のみ、期待される音符のインデックスを進める
                                    currentExpectedNoteIndex = (currentExpectedNoteIndex + 1) % expectedNotes.length;
                                    displayLoadedMusic(); // 読み込んだ楽譜表示を更新して、次の期待される音符を強調
                                } else {
                                    noteDisplayArea.classList.remove('correct');
                                    noteDisplayArea.classList.add('incorrect');
                                }
                            } else {
                                // 楽譜がない場合は色をリセット
                                noteDisplayArea.classList.remove('correct', 'incorrect');
                            }
                        }
                    }
                }
                // --- デバウンスロジック終了 ---

            } else { // 有意な音が検出されない場合（無音状態）
                // 最後に安定していた音階があれば、その期間を確定して履歴に追加
                if (currentStableNote.note !== null) {
                    const durationMs = performance.now() - lastStableNoteTime;
                    const noteDurationText = getNoteDurationText(durationMs, parseInt(tempoSelect.value));

                    let isCorrect = null;
                    if (expectedNotes.length > 0) {
                        const expectedNoteObj = expectedNotes[currentExpectedNoteIndex]; // 無音になる直前のcurrentStableNoteが、現在のexpectedNoteと一致するかを判定
                        isCorrect = (currentStableNote.note === expectedNoteObj.note && currentStableNote.octave === expectedNoteObj.octave);
                    }
                    
                    const newNoteEntry = {
                        note: currentStableNote.note,
                        octave: currentStableNote.octave,
                        durationText: noteDurationText,
                        isCorrect: isCorrect
                    };

                    if (newNoteEntry.note !== lastRecordedNoteInHistory.note ||
                        newNoteEntry.octave !== lastRecordedNoteInHistory.octave ||
                        newNoteEntry.durationText !== lastRecordedNoteInHistory.durationText ||
                        newNoteEntry.isCorrect !== lastRecordedNoteInHistory.isCorrect) {
                        
                        detectedNotesHistory.unshift(newNoteEntry);
                        if (detectedNotesHistory.length > MAX_HISTORY_ITEMS) {
                            detectedNotesHistory.pop();
                        }
                        historyGrid.innerHTML = detectedNotesHistory.map(item => `
                            <div class="history-item ${item.isCorrect === true ? 'correct-note' : (item.isCorrect === false ? 'incorrect-note' : '')}">
                                <p class="note-text">${item.note}${item.octave}</p>
                                <p class="duration-text">${item.durationText}</p>
                            </div>
                        `).join('');
                        lastRecordedNoteInHistory = newNoteEntry;
                    }
                    // 安定した音階の追跡をリセット
                    currentStableNote = { note: null, octave: null };
                    lastStableNoteTime = 0;
                }
                // デバウンス追跡もリセット
                debouncedNote = { note: null, octave: null };
                debouncedNoteStartTime = 0;

                // ライブ表示をクリア
                currentNoteDisplay.textContent = "---";
                currentOctaveDisplay.textContent = "";
                statusDisplay.textContent = 'マイク入力中... (音を待機中)';
                noteDisplayArea.classList.remove('correct', 'incorrect'); // 無音時は色をリセット
            }

            animationFrameId = requestAnimationFrame(processAudio);
        }

        // マイクを停止する関数
        function stopMicrophone() {
            if (mediaStreamSource) {
                mediaStreamSource.mediaStream.getTracks().forEach(track => track.stop());
                mediaStreamSource.disconnect();
                mediaStreamSource = null;
            }
            if (audioContext) {
                if (audioContext.state !== 'closed') {
                    audioContext.close().then(() => {
                        audioContext = null;
                        console.log('AudioContext closed');
                    });
                }
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            statusDisplay.textContent = '停止しました';
            startButton.disabled = false;
            stopButton.disabled = true;
            hideErrorMessage();
            currentNoteDisplay.textContent = "---";
            currentOctaveDisplay.textContent = "";
            noteDisplayArea.classList.remove('correct', 'incorrect');
            
            // 停止時に現在の音符が確定していれば履歴に追加
            if (currentStableNote.note !== null) {
                const durationMs = performance.now() - lastStableNoteTime;
                const noteDurationText = getNoteDurationText(durationMs, parseInt(tempoSelect.value));
                
                let isLastNoteCorrect = null;
                if (expectedNotes.length > 0) {
                    const expectedNoteObj = expectedNotes[currentExpectedNoteIndex];
                    if (currentStableNote.note === expectedNoteObj.note && currentStableNote.octave === expectedNoteObj.octave) {
                        isLastNoteCorrect = true;
                    } else {
                        isLastNoteCorrect = false;
                    }
                }

                const newNoteEntry = {
                    note: currentStableNote.note,
                    octave: currentStableNote.octave,
                    durationText: noteDurationText,
                    isCorrect: isLastNoteCorrect
                };

                if (newNoteEntry.note !== lastRecordedNoteInHistory.note ||
                    newNoteEntry.octave !== lastRecordedNoteInHistory.octave ||
                    newNoteEntry.durationText !== lastRecordedNoteInHistory.durationText ||
                    newNoteEntry.isCorrect !== lastRecordedNoteInHistory.isCorrect) {
                    
                    detectedNotesHistory.unshift(newNoteEntry);
                    if (detectedNotesHistory.length > MAX_HISTORY_ITEMS) {
                        detectedNotesHistory.pop();
                    }
                    historyGrid.innerHTML = detectedNotesHistory.map(item => `
                        <div class="history-item ${item.isCorrect === true ? 'correct-note' : (item.isCorrect === false ? 'incorrect-note' : '')}">
                            <p class="note-text">${item.note}${item.octave}</p>
                            <p class="duration-text">${item.durationText}</p>
                        </div>
                    `).join('');
                    lastRecordedNoteInHistory = newNoteEntry;
                }
            }

            // 停止時に履歴記録およびデバウンス用の変数をリセット
            currentStableNote = { note: null, octave: null };
            lastStableNoteTime = 0;
            lastRecordedNoteInHistory = { note: null, octave: null, durationText: null, isCorrect: null };
            debouncedNote = { note: null, octave: null };
            debouncedNoteStartTime = 0;
            displayLoadedMusic();
        }

        // イベントリスナー
        startButton.addEventListener('click', startMicrophone);
        stopButton.addEventListener('click', stopMicrophone);
        tempoSelect.addEventListener('change', updateTempoInfo);

        clearHistoryButton.addEventListener('click', () => {
            detectedNotesHistory = [];
            historyGrid.innerHTML = '';
            lastRecordedNoteInHistory = { note: null, octave: null, durationText: null, isCorrect: null };
            currentExpectedNoteIndex = 0;
            // 楽譜が読み込まれていれば、最初の音を表示
            statusDisplay.textContent = `楽譜ファイルの状態: ${expectedNotes[0] ? expectedNotes[0].note + expectedNotes[0].octave + 'から開始' : 'なし'}`;
            noteDisplayArea.classList.remove('correct', 'incorrect');
            currentNoteDisplay.style.color = '';
            currentOctaveDisplay.style.color = '';
            displayLoadedMusic();
        });

        // ファイル選択時のイベントリスナー
        musicFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            loadMusicFile(file);
        });

        // ページロード時に自動的にmusic.txtを読み込み、テンポ情報を初期表示
        window.onload = async () => {
            await loadMusicFile(); // music.txtの自動読み込みを試行
            updateTempoInfo();
            // 初期状態ではファイル選択を促すメッセージを表示
            displayLoadedMusic();
        };
    </script>
</body>
</html>
